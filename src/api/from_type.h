#ifndef CTF_FROM_TYPE_H
#define CTF_FROM_TYPE_H

#include "file/errors.h"
#include "type/type.h"

/*
 * As all public types in libctf are opaque, user of the library should not
 * access any struct/union members directly. One type of such API functions
 * is the one generated by FROM_TYPE macro. Normally, these functions are
 * named as _init with prefix being the specific type name (e.g. 
 * ctf_float_init).
 * 
 * To create an imitation of inheritance, each ctf_type contains two member
 * variables that are tightly coupled: the kind and binary data blob. The 
 * bond should never be broken - in case that the user uses only the public
 * API functions, this never happens. Depending on the content of the kind,
 * the data member contains a pointer to corresponding ctf_ opaque type. 
 * This data is type-casted to a correct type.
 *
 * In case of all participant types being not NULL, CTF_OK is returned,
 * CTF_E_NULL otherwise.
 */

#define _CTF_FROM_TYPE_PROTO(FUNCTION_NAME, SPECIFIC_TYPE) \
int \
FUNCTION_NAME (ctf_type type, SPECIFIC_TYPE* out);

#define _CTF_FROM_TYPE_IMPL(FUNCTION_NAME, SPECIFIC_TYPE) \
int \
FUNCTION_NAME (ctf_type type, SPECIFIC_TYPE* out) \
{ \
	if (type && type->data && out) \
	{ \
		*out = type->data; \
		return CTF_OK; \
	} \
	else \
		return CTF_E_NULL; \
}

#endif

